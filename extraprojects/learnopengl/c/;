#include "../include/obh_defs.h"
#include "../include/includes_dot_haitch.h"
#include "../include/shader_utils.h"

#ifndef STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_IMPLEMENTATION
#include "../external/stb/stb_image.h"
#endif

#ifndef STB_DS_IMPLEMENTATION
#define STB_DS_IMPLEMENTATION
#include "../external/stb/stb_ds.h"
#endif

#include "shapes.c"
#include "camera.c"

/*
 * **********************
 * ======================
 * obh C project template
 * ======================
 * **********************
 */

/* DECLARATIONS */
#define INIT_SCR_WIDTH 800
#define INIT_SCR_HEIGHT 600
#define INIT_GL_VER_MAJ 4
#define INIT_GL_VER_MIN 6

static int scr_width = INIT_SCR_WIDTH;
static int scr_height = INIT_SCR_HEIGHT;

static u32 UPS = 60;
static u32 frame_time_ms;
static u64 nsec_start;

static bool paused;
static bool use_texture;

vec3 light_source_pos = {30, 50, 30};
vec3 light_source_color = {1.0, 1.0, 1.0};
float light_ambient_str = 0.1;


static bool  cursor_first_time = true;
static float cursor_last_x = INIT_SCR_WIDTH / 2.0;
static float cursor_last_y = INIT_SCR_HEIGHT / 2.0;;
static float cursor_sens = 0.05;

static struct camera player_camera = {
    .pos      = {0.0, 0.0, -110.0},
    .dir      = {0.0, 0.0,  1.0},
    .up       = {0.0, 1.0,  0.0},
    .up_world = {0.0, 1.0,  0.0},
    
    .yaw   = 90.0,
    .pitch = 00.0,
    .zoom  = 45.0,

    .sens   = 0.05,
    .speed  = 0.55,

    .draw_dist = 500.0,
    .restrict_pitch = false,
    .camtype = FLYING,
};

/* LOGIC */
bool cubes_should_rotate = true;

/* FUNCTIONS */

void
framebuffer_size_callback(GLFWwindow *win, int width, int height)
{
    scr_width = width;
    scr_height = height;
    glViewport(0, 0, width, height);
}

void 
key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, true);
    }
    if (key == GLFW_KEY_SPACE && action == GLFW_PRESS) {
        paused = !paused;
    }
    if (key == GLFW_KEY_R && action == GLFW_PRESS) {
        cubes_should_rotate = !cubes_should_rotate;
    }
    if (key == GLFW_KEY_J && action == GLFW_PRESS) {
        player_camera.speed = fmax((player_camera.speed - 0.05), 0.01);
    }
    if (key == GLFW_KEY_L && action == GLFW_PRESS) {
        player_camera.speed = fmin((player_camera.speed + 0.05), 0.95);
    }
    if (key == GLFW_KEY_K && action == GLFW_PRESS) {
        player_camera.sens = fmax((player_camera.sens - 0.01), 0.01);
    }
    if (key == GLFW_KEY_I && action == GLFW_PRESS) {
        player_camera.sens = fmin((player_camera.sens + 0.01), 0.75);
    }
    // DEBUG
    if (key == GLFW_KEY_BACKSLASH && action == GLFW_PRESS) {
        fprintf(stderr, "cam props: ");
        fprintf(stderr, "pos: %.2f %.2f %.2f | ", player_camera.pos.x, player_camera.pos.y, player_camera.pos.z);
        fprintf(stderr, "right: %.2f %.2f %.2f | ", player_camera.right.x, player_camera.right.y, player_camera.right.z);
        fprintf(stderr, "left: %.2f %.2f %.2f | ", player_camera.left.x, player_camera.left.y, player_camera.left.z);
        fprintf(stderr, "up: %.2f %.2f %.2f | ", player_camera.up.x, player_camera.up.y, player_camera.up.z);
        fprintf(stderr, "at: %.2f %.2f %.2f | ", player_camera.at.x, player_camera.at.y, player_camera.at.z);
        fprintf(stderr, "dir: %.2f %.2f %.2f\n", player_camera.dir.x, player_camera.dir.y, player_camera.dir.z);
        fprintf(stderr, "speed/sens: %.2f %.2f\n", player_camera.speed, player_camera.sens);
        fprintf(stderr, "frame_time_ms: %u\n", frame_time_ms);
    }
}

void
mouse_callback(GLFWwindow *window, double x_pos, double y_pos)
{    
    if (paused || cursor_first_time) {
        cursor_last_x = x_pos;
        cursor_last_y = y_pos;
        cursor_first_time = false;
        return;
    }
    float x_offset = (float)x_pos - cursor_last_x;
    float y_offset = cursor_last_y - (float)y_pos;
    cursor_last_x = (float)x_pos;
    cursor_last_y = (float)y_pos;
    /**********************************************************************
     * NOTE: Guard against glfw's automatic re-centering of the cursor
     ******************************************************************** */
    float x_scr_c = scr_width / 2.0;
    float y_scr_c = scr_height / 2.0;
    float x_diff = abs(x_pos - x_scr_c);
    float y_diff = abs(y_pos - y_scr_c);
    if (x_diff < 1.0 && y_diff < 1.0)
        return;
    if (abs(x_offset) > scr_width / 2.0 || abs(y_offset) > scr_height / 2.0)
        return;
    /**********************************************************************/
    cam_update_dir(&player_camera, x_offset, y_offset);
//    cam_yaw   += x_offset * cursor_sens;
//    cam_pitch += y_offset * cursor_sens;
//    if (cam_pitch >  89.0)
//        cam_pitch =  89.0;
//    if (cam_pitch < -89.0)
//        cam_pitch = -89.0;
//
//    cam_dir[0] = cos(glm_rad(cam_yaw) * cos(glm_rad(cam_pitch)));
//    cam_dir[1] = sin(glm_rad(cam_pitch));
//    cam_dir[2] = sin(glm_rad(cam_yaw) * cos(glm_rad(cam_pitch)));
//    glm_vec3_normalize(cam_dir);
}

void
scroll_callback(GLFWwindow *window, double x_offset, double y_offset){
    cam_update_zoom(&player_camera, x_offset, y_offset);
}

void
process_input(GLFWwindow *window)
{
    if (paused)
        return;
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        cam_update_move(&player_camera, DIR_LEFT, 1);
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        cam_update_move(&player_camera, DIR_RIGHT, 1);
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        cam_update_move(&player_camera, DIR_FORWARD, 1);
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        cam_update_move(&player_camera, DIR_BACKWARD, 1);

    if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
        light_source_pos[0] += 1.0;
    if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)
        light_source_pos[0] -= 1.0;
    if (glfwGetKey(window, GLFW_KEY_COMMA) == GLFW_PRESS)
        light_source_pos[1] += 1.0;
    if (glfwGetKey(window, GLFW_KEY_PERIOD) == GLFW_PRESS)
        light_source_pos[1] -= 1.0;
    if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
        light_source_pos[2] += 1.0;
    if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
        light_source_pos[2] -= 1.0;
}

GLFWwindow*
startup(int width, int height, int gl_ver_maj, int gl_ver_min)
{
    // glfw: initialize and configure
    // ------------------------------
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

    GLFWwindow* window = 
        glfwCreateWindow(INIT_SCR_WIDTH, INIT_SCR_HEIGHT, "LearnOpenGL", NULL, NULL);
    if (window == NULL)
    {
        fprintf(stderr, "Failed to create GLFW window\n");
        glfwTerminate();
        return NULL;
    }

    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glfwSetCursorPosCallback(window, mouse_callback);
    glfwSetKeyCallback(window, key_callback);
    glfwSetScrollCallback(window, scroll_callback);

    // tell GLFW to capture our mouse
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    // glad: load all OpenGL function pointers
    // ---------------------------------------
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        fprintf(stderr, "Failed to initialize GLAD\n");
        return NULL;
    }

    // configure global opengl state
    // -----------------------------
    glEnable(GL_DEPTH_TEST);

    return window;
}

/* MAIN ENTRANCE */

#define unvec3(a) {(a)[0], (a)[1], (a)[2]}

int
main()
{
    /* INIT */
    srand(time(NULL));
    GLFWwindow *window = 
        startup(INIT_SCR_WIDTH, INIT_SCR_HEIGHT, INIT_GL_VER_MAJ, INIT_GL_VER_MIN);
    /* DATA */
    vec4 bg_color = { 0.0, 0.0, 0.0, 1.0 };

    /* SHADERS */
    shader_utils_set_shader_dir_vertex("shaders/vertex");
    shader_utils_set_shader_dir_fragment("shaders/fragment");
    u32 shader_arr[] = {
        shader_utils_compile(GL_VERTEX_SHADER, "lighting.vert"),
        shader_utils_compile(GL_FRAGMENT_SHADER, "lighting.frag"),
    };
    u32 shader_program = shader_utils_link_program(2, shader_arr);
    shader_utils_delete_shaders(2, shader_arr);

    u32 shader_arr_source[] = {
        shader_utils_compile(GL_VERTEX_SHADER, "lighting.vert"),
        shader_utils_compile(GL_FRAGMENT_SHADER, "lighting_source.frag"),
    };
    u32 shader_program_source = shader_utils_link_program(2, shader_arr_source);
    shader_utils_delete_shaders(2, shader_arr_source);

    /* GL BUFFERS */
    u32 VAO, VBO, EBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glGenBuffers(1, &EBO);

    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(shapes_cube_vertices), shapes_cube_vertices, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 8, (void*)0); 
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 8, (void*)(sizeof(float) * 3));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 8, (void*)(sizeof(float) * 6)); 
    glEnableVertexAttribArray(2);
    /* SHAPES */
    int n_cubes = 1000;
    vec3 cubes[n_cubes];
    for (int i = 0; i < n_cubes; ++i){
        // TODO: MINECRAFT CUBE GENERATION
        for (int j = 0; j < n_cubes / 10; ++j){
            vec3 v;
            v[0] = rand() % 80;
            v[1] = rand() % 80;
            v[2] = rand() % 80;
            glm_vec3_copy(v, cubes[i]);
        }
    }
    /* TEXTURE */
    glBindVertexArray(VAO);

    u32 tex1, tex2;
    glGenTextures(1, &tex1);
    glGenTextures(1, &tex2);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, tex1);

    int img_width, img_height, img_n_channels;
    u8 *img_data = stbi_load("resources/container.jpg", 
            &img_width, &img_height, &img_n_channels, 0);
    if (img_data){
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 
                img_width, img_height, 0, GL_RGB, GL_UNSIGNED_BYTE, img_data);
        glGenerateMipmap(GL_TEXTURE_2D);
        stbi_image_free(img_data);
    } else
        fprintf(stderr, "failed to load image");

    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, tex2);

    stbi_set_flip_vertically_on_load(true);
    img_data = stbi_load("resources/awesomeface.png", 
            &img_width, &img_height, &img_n_channels, 0);
    if (img_data){
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 
                img_width, img_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, img_data);
        glGenerateMipmap(GL_TEXTURE_2D);
        stbi_image_free(img_data);
    } else
        fprintf(stderr, "failed to load image");

    glUseProgram(shader_program);
    glUniform1i(glGetUniformLocation(shader_program, "container_tex_1"), 0);
    glUniform1i(glGetUniformLocation(shader_program, "container_tex_2"), 1);
    glUseProgram(0);

    glBindVertexArray(0);

    /* TIME */
    u64 updates = 0;

    struct timespec time_spec;
    clock_gettime(CLOCK_REALTIME, &time_spec);
    nsec_start = time_spec.tv_sec * 1000000000 + time_spec.tv_nsec;
    u64 microsec_start = nsec_start / 1000;
    u64 microsec_lastupdate = 0;
    u64 microsec_lastrender = 0;
    u64 microsec_delta = 1000000;
    u64 microsec_now = microsec_start;
    u64 microsec_update_time = 1000000 / UPS;

    /* MATH */
    mat4 rot_mat = GLM_MAT4_IDENTITY_INIT;
    float angle, rots_per_sec = 4.0;
    float ups_to_radians = (2.0 * M_PI) / (rots_per_sec * (float)UPS);

    /* MAIN LOOP */
    while (!(glfwWindowShouldClose(window))) {
        /* TIME */
        clock_gettime(CLOCK_REALTIME, &time_spec);
        u64 nsec_now = time_spec.tv_sec * 1000000000 + time_spec.tv_nsec;
        microsec_now = nsec_now / 1000;
        microsec_delta = microsec_now - microsec_lastupdate;
        frame_time_ms = microsec_delta / 1000;
        if (microsec_delta < microsec_update_time){
            usleep(microsec_update_time - microsec_delta);
            microsec_now += microsec_update_time - microsec_delta;
        }
        microsec_lastupdate = microsec_now;
        /* INPUT */
        process_input(window);
        /* EVENTS */
        glfwPollEvents();
        /* UPDATE */
        if (!paused)
            ++updates;
        else {
            continue;
        }

        /* RENDER */
        glClearColor(bg_color[0], bg_color[1], bg_color[2], bg_color[3]);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        // DRAWING CUBES
        glBindVertexArray(VAO);
        glUseProgram(shader_program);

        // LIGHTING
        int cam_pos_loc = glGetUniformLocation(shader_program, "cam_pos");
        int light_pos_loc = glGetUniformLocation(shader_program, "light_pos");
        int light_col_loc = glGetUniformLocation(shader_program, "light_col");
        int ambient_str_loc = glGetUniformLocation(shader_program, "ambient_str");
        int specular_str_loc = glGetUniformLocation(shader_program, "specular_str");
        int use_texture_loc = glGetUniformLocation(shader_program, "use_texture");

        glUniform3fv(cam_pos_loc, 1, (float*)player_camera.pos.vec);
        glUniform3fv(light_pos_loc, 1, (float*)light_source_pos);
        glUniform3fv(light_col_loc, 1, (float*)light_source_color);
        glUniform1f(ambient_str_loc, light_ambient_str);
        glUniform1f(specular_str_loc, 0.4);
        glUniform1i(specular_str_loc, use_texture);

        mat4 view = GLM_MAT4_IDENTITY_INIT;
        mat4 proj = GLM_MAT4_IDENTITY_INIT;

        cam_get_view(&player_camera, &view);
        glm_perspective(
                glm_rad(player_camera.zoom), 
                (float)scr_width / (float)scr_height, 0.1, 
                player_camera.draw_dist, 
                proj);

        int view_loc = glGetUniformLocation(shader_program, "view");
        int proj_loc = glGetUniformLocation(shader_program, "proj");
        int modl_loc = glGetUniformLocation(shader_program, "modl");

        glUniformMatrix4fv(view_loc, 1, GL_FALSE, (float*)view);
        glUniformMatrix4fv(proj_loc, 1, GL_FALSE, (float*)proj);

        double secs = glfwGetTime() / 05.0;
        for (int i = 0; i < n_cubes; ++i){
            float angle = glm_rad(2.0 * i + 7.0);
            angle *= secs;

            mat4 modl = GLM_MAT4_IDENTITY_INIT;
            glm_translate(modl, cubes[i]);
            if (cubes_should_rotate)
                glm_rotate(modl, angle, (vec3){1.0, 1.0, 1.0});
            glUniformMatrix4fv(modl_loc, 1, GL_FALSE, (float*)modl);

            glDrawArrays(GL_TRIANGLES, 0, 36);
        }

        glUseProgram(0);
        glUseProgram(shader_program_source);

        for (int i = 0; i < 1; ++i){
            int view_loc_ls = glGetUniformLocation(shader_program_source, "view");
            int proj_loc_ls = glGetUniformLocation(shader_program_source, "proj");
            int modl_loc_ls = glGetUniformLocation(shader_program_source, "modl");

            glUniformMatrix4fv(view_loc_ls, 1, GL_FALSE, (float*)view);
            glUniformMatrix4fv(proj_loc_ls, 1, GL_FALSE, (float*)proj);

            mat4 modl = GLM_MAT4_IDENTITY_INIT;
            glm_translate(modl, light_source_pos);
            glUniformMatrix4fv(modl_loc_ls, 1, GL_FALSE, (float*)modl);

            glDrawArrays(GL_TRIANGLES, 0, 36);
        }

        glUseProgram(0);
        glBindVertexArray(0);
        // END DRAWING CUBES

//        /* SWAP BUFFERS */
//        if (microsec_now - microsec_lastrender >= microsec_update_time){
        glfwSwapBuffers(window);
//            microsec_lastrender = microsec_now;
//        }
    }

    glfwTerminate();
}
